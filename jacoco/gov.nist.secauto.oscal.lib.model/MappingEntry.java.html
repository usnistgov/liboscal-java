<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MappingEntry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OSCAL Java Library</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.oscal.lib.model</a> &gt; <span class="el_source">MappingEntry.java</span></div><h1>MappingEntry.java</h1><pre class="source lang-java linenums">package gov.nist.secauto.oscal.lib.model;

import gov.nist.secauto.metaschema.binding.model.annotations.AllowedValue;
import gov.nist.secauto.metaschema.binding.model.annotations.AllowedValues;
import gov.nist.secauto.metaschema.binding.model.annotations.BoundAssembly;
import gov.nist.secauto.metaschema.binding.model.annotations.BoundField;
import gov.nist.secauto.metaschema.binding.model.annotations.BoundFieldValue;
import gov.nist.secauto.metaschema.binding.model.annotations.BoundFlag;
import gov.nist.secauto.metaschema.binding.model.annotations.GroupAs;
import gov.nist.secauto.metaschema.binding.model.annotations.MetaschemaAssembly;
import gov.nist.secauto.metaschema.binding.model.annotations.MetaschemaField;
import gov.nist.secauto.metaschema.binding.model.annotations.MetaschemaFieldValue;
import gov.nist.secauto.metaschema.binding.model.annotations.ValueConstraints;
import gov.nist.secauto.metaschema.model.common.JsonGroupAsBehavior;
import gov.nist.secauto.metaschema.model.common.constraint.IConstraint;
import gov.nist.secauto.metaschema.model.common.datatype.adapter.TokenAdapter;
import gov.nist.secauto.metaschema.model.common.datatype.adapter.UriAdapter;
import gov.nist.secauto.metaschema.model.common.datatype.adapter.UuidAdapter;
import gov.nist.secauto.metaschema.model.common.datatype.markup.MarkupMultiline;
import gov.nist.secauto.metaschema.model.common.datatype.markup.MarkupMultilineAdapter;
import gov.nist.secauto.metaschema.model.common.util.ObjectUtils;
import java.lang.Override;
import java.lang.String;
import java.net.URI;
import java.util.LinkedList;
import java.util.List;
import java.util.UUID;
import org.apache.commons.lang3.builder.MultilineRecursiveToStringStyle;
import org.apache.commons.lang3.builder.ReflectionToStringBuilder;

/**
 * A relationship-based mapping between a source and target set consisting of members (i.e., controls, control statements) from the respective source and target.
 */
@MetaschemaAssembly(
    formalName = &quot;Mapping Entry&quot;,
    description = &quot;A relationship-based mapping between a source and target set consisting of members (i.e., controls, control statements) from the respective source and target.&quot;,
    name = &quot;map&quot;,
    metaschema = OscalMappingCommonMetaschema.class
)
public class MappingEntry {
  @BoundFlag(
      formalName = &quot;Mapping Entry Identifier&quot;,
      description = &quot;The unique identifier for the mapping entry.&quot;,
      useName = &quot;uuid&quot;,
      required = true,
      typeAdapter = UuidAdapter.class
  )
  private UUID _uuid;

  @BoundAssembly(
      formalName = &quot;Property&quot;,
      description = &quot;An attribute, characteristic, or quality of the containing object expressed as a namespace qualified name/value pair.&quot;,
      useName = &quot;prop&quot;,
      maxOccurs = -1
  )
  @GroupAs(
      name = &quot;props&quot;,
      inJson = JsonGroupAsBehavior.LIST
  )
  private List&lt;Property&gt; _props;

  @BoundAssembly(
      formalName = &quot;Link&quot;,
      description = &quot;A reference to a local or remote resource, that has a specific relation to the containing object.&quot;,
      useName = &quot;link&quot;,
      maxOccurs = -1
  )
  @GroupAs(
      name = &quot;links&quot;,
      inJson = JsonGroupAsBehavior.LIST
  )
  private List&lt;Link&gt; _links;

  /**
   * &quot;The relationship type for the mapping entry, which describes the relationship between the effective requirements of the specified source and target sets.&quot;
   */
  @BoundField(
      formalName = &quot;Mapping Entry Relationship&quot;,
      description = &quot;The relationship type for the mapping entry, which describes the relationship between the effective requirements of the specified source and target sets.&quot;,
      useName = &quot;relationship&quot;,
      minOccurs = 1,
      remarks = &quot;When establishing relationships, mapping SHOULD be done at the control statement level where possible. This approach allows for more use of 'equivalent-to', which represents a stronger relationship than the other relationship types.&quot;
  )
  private Relationship _relationship;

  @BoundAssembly(
      formalName = &quot;Mapping Entry Item (source or target)&quot;,
      description = &quot;Identifies a specific edge within a source or target that is the subject of a mapping.&quot;,
      useName = &quot;source&quot;,
      minOccurs = 1,
      maxOccurs = -1
  )
  @GroupAs(
      name = &quot;sources&quot;,
      inJson = JsonGroupAsBehavior.LIST
  )
  private List&lt;MappingItem&gt; _sources;

  @BoundAssembly(
      formalName = &quot;Mapping Entry Item (source or target)&quot;,
      description = &quot;Identifies a specific edge within a source or target that is the subject of a mapping.&quot;,
      useName = &quot;target&quot;,
      minOccurs = 1,
      maxOccurs = -1
  )
  @GroupAs(
      name = &quot;targets&quot;,
      inJson = JsonGroupAsBehavior.LIST
  )
  private List&lt;MappingItem&gt; _targets;

  @BoundField(
      formalName = &quot;Remarks&quot;,
      description = &quot;Additional commentary about the containing object.&quot;,
      useName = &quot;remarks&quot;
  )
  @BoundFieldValue(
      typeAdapter = MarkupMultilineAdapter.class
  )
  private MarkupMultiline _remarks;

<span class="nc" id="L122">  public MappingEntry() {</span>
<span class="nc" id="L123">  }</span>

  public UUID getUuid() {
<span class="nc" id="L126">    return _uuid;</span>
  }

  public void setUuid(UUID value) {
<span class="nc" id="L130">    _uuid = value;</span>
<span class="nc" id="L131">  }</span>

  public List&lt;Property&gt; getProps() {
<span class="nc" id="L134">    return _props;</span>
  }

  public void setProps(List&lt;Property&gt; value) {
<span class="nc" id="L138">    _props = value;</span>
<span class="nc" id="L139">  }</span>

  /**
   * Add a new {@link Property} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addProp(Property item) {
<span class="nc" id="L147">    Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">    if (_props == null) {</span>
<span class="nc" id="L149">      _props = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L151">    return _props.add(value);</span>
  }

  /**
   * Remove the first matching {@link Property} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeProp(Property item) {
<span class="nc" id="L160">    Property value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">    return _props == null ? false : _props.remove(value);</span>
  }

  public List&lt;Link&gt; getLinks() {
<span class="nc" id="L165">    return _links;</span>
  }

  public void setLinks(List&lt;Link&gt; value) {
<span class="nc" id="L169">    _links = value;</span>
<span class="nc" id="L170">  }</span>

  /**
   * Add a new {@link Link} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addLink(Link item) {
<span class="nc" id="L178">    Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">    if (_links == null) {</span>
<span class="nc" id="L180">      _links = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L182">    return _links.add(value);</span>
  }

  /**
   * Remove the first matching {@link Link} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeLink(Link item) {
<span class="nc" id="L191">    Link value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    return _links == null ? false : _links.remove(value);</span>
  }

  public Relationship getRelationship() {
<span class="nc" id="L196">    return _relationship;</span>
  }

  public void setRelationship(Relationship value) {
<span class="nc" id="L200">    _relationship = value;</span>
<span class="nc" id="L201">  }</span>

  public List&lt;MappingItem&gt; getSources() {
<span class="nc" id="L204">    return _sources;</span>
  }

  public void setSources(List&lt;MappingItem&gt; value) {
<span class="nc" id="L208">    _sources = value;</span>
<span class="nc" id="L209">  }</span>

  /**
   * Add a new {@link MappingItem} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addSource(MappingItem item) {
<span class="nc" id="L217">    MappingItem value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">    if (_sources == null) {</span>
<span class="nc" id="L219">      _sources = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L221">    return _sources.add(value);</span>
  }

  /**
   * Remove the first matching {@link MappingItem} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeSource(MappingItem item) {
<span class="nc" id="L230">    MappingItem value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">    return _sources == null ? false : _sources.remove(value);</span>
  }

  public List&lt;MappingItem&gt; getTargets() {
<span class="nc" id="L235">    return _targets;</span>
  }

  public void setTargets(List&lt;MappingItem&gt; value) {
<span class="nc" id="L239">    _targets = value;</span>
<span class="nc" id="L240">  }</span>

  /**
   * Add a new {@link MappingItem} item to the underlying collection.
   * @param item the item to add
   * @return {@code true}
   */
  public boolean addTarget(MappingItem item) {
<span class="nc" id="L248">    MappingItem value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">    if (_targets == null) {</span>
<span class="nc" id="L250">      _targets = new LinkedList&lt;&gt;();</span>
    }
<span class="nc" id="L252">    return _targets.add(value);</span>
  }

  /**
   * Remove the first matching {@link MappingItem} item from the underlying collection.
   * @param item the item to remove
   * @return {@code true} if the item was removed or {@code false} otherwise
   */
  public boolean removeTarget(MappingItem item) {
<span class="nc" id="L261">    MappingItem value = ObjectUtils.requireNonNull(item,&quot;item cannot be null&quot;);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">    return _targets == null ? false : _targets.remove(value);</span>
  }

  public MarkupMultiline getRemarks() {
<span class="nc" id="L266">    return _remarks;</span>
  }

  public void setRemarks(MarkupMultiline value) {
<span class="nc" id="L270">    _remarks = value;</span>
<span class="nc" id="L271">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L275">    return new ReflectionToStringBuilder(this, MultilineRecursiveToStringStyle.MULTI_LINE_STYLE).toString();</span>
  }

  /**
   * The relationship type for the mapping entry, which describes the relationship between the effective requirements of the specified source and target sets.
   */
  @MetaschemaField(
      formalName = &quot;Mapping Entry Relationship&quot;,
      description = &quot;The relationship type for the mapping entry, which describes the relationship between the effective requirements of the specified source and target sets.&quot;,
      name = &quot;relationship&quot;,
      metaschema = OscalMappingCommonMetaschema.class,
      isCollapsible = false
  )
  @ValueConstraints(
      allowedValues = @AllowedValues(level = IConstraint.Level.ERROR, target = &quot;.[has-oscal-namespace('http://csrc.nist.gov/ns/oscal')]&quot;, values = {@AllowedValue(value = &quot;equivalent-to&quot;, description = &quot;The effective requirements of the source is equivalent in semantic meaning to the effective requirements of the target. The words may differ, but both mapped sets convey similar information with the same effective meaning. This relationship may be reversed, since \\`A equivalent-to B\\` also means that \\`B equivalent-to A\\`.&quot;), @AllowedValue(value = &quot;equal-to&quot;, description = &quot;The actual requirements of the source are the same as the actual requirements target. Differences in capitalization, spelling, and grammar can be ignored, if these differences do not change the meaning. This relationship may be reversed, since \\`A equal-to B\\` also means that \\`B equal-to A\\`.&quot;), @AllowedValue(value = &quot;subset-of&quot;, description = &quot;The effective requirements of the source is a semantic subset of the effective requirements of the target. This relationship may be reversed as a \\`superset-of\\`, since \\`A subset-of B\\` also means that \\`B superset-of A\\`.&quot;), @AllowedValue(value = &quot;superset-of&quot;, description = &quot;The effective requirements of the source is a semantic superset of the effective requirements of the target. This relationship may be reversed as a \\`subset-of\\`, since \\`A superset-of B\\` also means that \\`B subset-of A\\`.&quot;), @AllowedValue(value = &quot;intersects-with&quot;, description = &quot;The effective requirements of the source and target have some semantic equivalence, but not all effective requirements from each are contained within the other. This relationship may be reversed, since \\`A intersects-with B\\` also means that \\`B intersects-with A\\`. A lower granularity mapping, such as a statement level mapping using 'equivalent-to', 'subset-of', and/or 'superset-of', may provide a more functional mapping that allows for more inference than using this relationship type.&quot;)})
  )
  public static class Relationship {
    @MetaschemaFieldValue(
        valueKeyName = &quot;type&quot;,
        typeAdapter = TokenAdapter.class
    )
    private String _value;

    @BoundFlag(
        formalName = &quot;Relationship Value Namespace&quot;,
        description = &quot;A namespace qualifying the relationship's value. This allows different organizations to associate distinct semantics for relationships with the same name.&quot;,
        useName = &quot;ns&quot;,
        typeAdapter = UriAdapter.class,
        remarks = &quot;This value must be an [absolute URI](https://pages.nist.gov/OSCAL/concepts/uri-use/#absolute-uri) that serves as a [naming system identifier](https://pages.nist.gov/OSCAL/concepts/uri-use/#use-as-a-naming-system-identifier).\n&quot;
                + &quot;\n&quot;
                + &quot;When a `ns` is not provided, its value should be assumed to be `http://csrc.nist.gov/ns/oscal` and the name should be a name defined by the associated OSCAL model.&quot;
    )
    private URI _ns;

<span class="nc" id="L309">    public Relationship() {</span>
<span class="nc" id="L310">    }</span>

    public String getValue() {
<span class="nc" id="L313">      return _value;</span>
    }

    public void setValue(String value) {
<span class="nc" id="L317">      _value = value;</span>
<span class="nc" id="L318">    }</span>

    public URI getNs() {
<span class="nc" id="L321">      return _ns;</span>
    }

    public void setNs(URI value) {
<span class="nc" id="L325">      _ns = value;</span>
<span class="nc" id="L326">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L330">      return new ReflectionToStringBuilder(this, MultilineRecursiveToStringStyle.MULTI_LINE_STYLE).toString();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>