<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RemoveVisitor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OSCAL Java Library</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.oscal.lib.profile.resolver.alter</a> &gt; <span class="el_source">RemoveVisitor.java</span></div><h1>RemoveVisitor.java</h1><pre class="source lang-java linenums">/*
 * Portions of this software was developed by employees of the National Institute
 * of Standards and Technology (NIST), an agency of the Federal Government and is
 * being made available as a public service. Pursuant to title 17 United States
 * Code Section 105, works of NIST employees are not subject to copyright
 * protection in the United States. This software may be subject to foreign
 * copyright. Permission in the United States and in foreign countries, to the
 * extent that NIST may hold copyright, to use, copy, modify, create derivative
 * works, and distribute this software and its documentation without fee is hereby
 * granted on a non-exclusive basis, provided that this notice and disclaimer
 * of warranty appears in all copies.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM
 * INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE
 * SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR FREE.  IN NO EVENT
 * SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT,
 * INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM,
 * OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT, OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR
 * PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT
 * OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.
 */

package gov.nist.secauto.oscal.lib.profile.resolver.alter;

import gov.nist.secauto.metaschema.model.common.util.CollectionUtil;
import gov.nist.secauto.metaschema.model.common.util.ObjectUtils;
import gov.nist.secauto.oscal.lib.model.Catalog;
import gov.nist.secauto.oscal.lib.model.CatalogGroup;
import gov.nist.secauto.oscal.lib.model.Control;
import gov.nist.secauto.oscal.lib.model.ControlPart;
import gov.nist.secauto.oscal.lib.model.Link;
import gov.nist.secauto.oscal.lib.model.Parameter;
import gov.nist.secauto.oscal.lib.model.Property;
import gov.nist.secauto.oscal.lib.model.control.catalog.ICatalogVisitor;
import gov.nist.secauto.oscal.lib.model.metadata.IProperty;
import gov.nist.secauto.oscal.lib.profile.resolver.ProfileResolutionEvaluationException;

import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Supplier;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

<span class="nc" id="L57">public class RemoveVisitor implements ICatalogVisitor&lt;Boolean, RemoveVisitor.Context&gt; {</span>
<span class="nc" id="L58">  public enum TargetType {</span>
<span class="nc" id="L59">    PARAM(&quot;param&quot;, Parameter.class),</span>
<span class="nc" id="L60">    PROP(&quot;prop&quot;, Property.class),</span>
<span class="nc" id="L61">    LINK(&quot;link&quot;, Link.class),</span>
<span class="nc" id="L62">    PART(&quot;part&quot;, ControlPart.class);</span>

    @NonNull
    private static final Map&lt;Class&lt;?&gt;, TargetType&gt; CLASS_TO_TYPE;
    @NonNull
    private static final Map&lt;String, TargetType&gt; NAME_TO_TYPE;
    @NonNull
    private final String fieldName;
    @NonNull
    private final Class&lt;?&gt; clazz;

    static {
      {
<span class="nc" id="L75">        Map&lt;Class&lt;?&gt;, TargetType&gt; map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">        for (TargetType type : TargetType.values()) {</span>
<span class="nc" id="L77">          map.put(type.getClazz(), type);</span>
        }
<span class="nc" id="L79">        CLASS_TO_TYPE = CollectionUtil.unmodifiableMap(map);</span>
      }

      {
<span class="nc" id="L83">        Map&lt;String, TargetType&gt; map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        for (TargetType type : TargetType.values()) {</span>
<span class="nc" id="L85">          map.put(type.fieldName(), type);</span>
        }
<span class="nc" id="L87">        NAME_TO_TYPE = CollectionUtil.unmodifiableMap(map);</span>
      }
<span class="nc" id="L89">    }</span>

    /**
     * Get the target type associated with the provided {@code clazz}.
     *
     * @param clazz
     *          the class to identify the target type for
     * @return the associated target type or {@code null} if the class is not
     *         associated with a target type
     */
    @Nullable
    public static TargetType forClass(@NonNull Class&lt;?&gt; clazz) {
<span class="nc" id="L101">      Class&lt;?&gt; target = clazz;</span>
      TargetType retval;
      // recurse over parent classes to find a match
      do {
<span class="nc" id="L105">        retval = CLASS_TO_TYPE.get(target);</span>
<span class="nc bnc" id="L106" title="All 4 branches missed.">      } while (retval == null &amp;&amp; (target = target.getSuperclass()) != null);</span>
<span class="nc" id="L107">      return retval;</span>
    }

    /**
     * Get the target type associated with the provided field {@code name}.
     *
     * @param name
     *          the field name to identify the target type for
     * @return the associated target type or {@code null} if the name is not
     *         associated with a target type
     */
    @Nullable
    public static TargetType forFieldName(@Nullable String name) {
<span class="nc bnc" id="L120" title="All 2 branches missed.">      return name == null ? null : NAME_TO_TYPE.get(name);</span>
    }

<span class="nc" id="L123">    TargetType(@NonNull String fieldName, @NonNull Class&lt;?&gt; clazz) {</span>
<span class="nc" id="L124">      this.fieldName = fieldName;</span>
<span class="nc" id="L125">      this.clazz = clazz;</span>
<span class="nc" id="L126">    }</span>

    /**
     * Get the field name associated with the target type.
     *
     * @return the name
     */
    public String fieldName() {
<span class="nc" id="L134">      return fieldName;</span>
    }

    /**
     * Get the bound class associated with the target type.
     *
     * @return the class
     */
    public Class&lt;?&gt; getClazz() {
<span class="nc" id="L143">      return clazz;</span>
    }

  }

  @NonNull
<span class="nc" id="L149">  private static final RemoveVisitor INSTANCE = new RemoveVisitor();</span>

  private static final Map&lt;TargetType, Set&lt;TargetType&gt;&gt; APPLICABLE_TARGETS;

  static {
<span class="nc" id="L154">    APPLICABLE_TARGETS = new EnumMap&lt;&gt;(TargetType.class);</span>
<span class="nc" id="L155">    APPLICABLE_TARGETS.put(TargetType.PARAM, Set.of(TargetType.PROP, TargetType.LINK));</span>
<span class="nc" id="L156">    APPLICABLE_TARGETS.put(TargetType.PART, Set.of(TargetType.PART, TargetType.PROP, TargetType.LINK));</span>
<span class="nc" id="L157">  }</span>

  private static Set&lt;TargetType&gt; getApplicableTypes(@NonNull TargetType type) {
<span class="nc" id="L160">    return APPLICABLE_TARGETS.getOrDefault(type, CollectionUtil.emptySet());</span>
  }

  private static &lt;T&gt; boolean handle(
      @NonNull TargetType itemType,
      @NonNull Supplier&lt;? extends Collection&lt;T&gt;&gt; supplier,
      @Nullable Function&lt;T, Boolean&gt; handler,
      @NonNull Context context) {

<span class="nc bnc" id="L169" title="All 2 branches missed.">    boolean handleChildren = !Collections.disjoint(context.getTargetItemTypes(), getApplicableTypes(itemType));</span>
<span class="nc" id="L170">    boolean retval = false;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">    if (context.isMatchingType(itemType)) {</span>
      // if the item type is applicable, attempt to remove any items
<span class="nc" id="L173">      Iterator&lt;T&gt; iter = supplier.get().iterator();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">      while (iter.hasNext()) {</span>
<span class="nc" id="L175">        T item = iter.next();</span>

<span class="nc bnc" id="L177" title="All 4 branches missed.">        if (item == null || context.isApplicableTo(item)) {</span>
<span class="nc" id="L178">          iter.remove();</span>
<span class="nc" id="L179">          retval = true;</span>
          // ignore removed items and their children
<span class="nc bnc" id="L181" title="All 4 branches missed.">        } else if (handler != null &amp;&amp; handleChildren) {</span>
          // handle child items since they are applicable to the search criteria
<span class="nc bnc" id="L183" title="All 4 branches missed.">          retval = retval || handler.apply(item);</span>
        }
<span class="nc" id="L185">      }</span>
<span class="nc bnc" id="L186" title="All 4 branches missed.">    } else if (handleChildren &amp;&amp; handler != null) {</span>
      // if the child item type is applicable and there is a handler, iterate over
      // children
<span class="nc" id="L189">      Iterator&lt;T&gt; iter = supplier.get().iterator();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">      while (iter.hasNext()) {</span>
<span class="nc" id="L191">        T item = iter.next();</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (item != null) {</span>
<span class="nc bnc" id="L193" title="All 4 branches missed.">          retval = retval || handler.apply(item);</span>
        }
<span class="nc" id="L195">      }</span>
    }
<span class="nc" id="L197">    return retval;</span>
  }

  /**
   * Apply the remove directive.
   *
   * @param control
   *          the control target
   * @param objectName
   *          the name flag of a matching node to remove
   * @param objectClass
   *          the class flag of a matching node to remove
   * @param objectId
   *          the id flag of a matching node to remove
   * @param objectNamespace
   *          the namespace flag of a matching node to remove
   * @param itemType
   *          the type of a matching node to remove
   * @return {@code true} if the modification was made or {@code false} otherwise
   * @throws ProfileResolutionEvaluationException
   *           if a processing error occurred during profile resolution
   */
  public static boolean remove(
      @NonNull Control control,
      @Nullable String objectName,
      @Nullable String objectClass,
      @Nullable String objectId,
      @Nullable String objectNamespace,
      @Nullable TargetType itemType) {
<span class="nc" id="L226">    return INSTANCE.visitControl(</span>
        control,
        new Context(objectName, objectClass, objectId, objectNamespace, itemType));
  }

  @Override
  public Boolean visitCatalog(Catalog catalog, Context context) {
    // not required
<span class="nc" id="L234">    throw new UnsupportedOperationException(&quot;not needed&quot;);</span>
  }

  @Override
  public Boolean visitGroup(CatalogGroup group, Context context) {
    // not required
<span class="nc" id="L240">    throw new UnsupportedOperationException(&quot;not needed&quot;);</span>
  }

  @Override
  public Boolean visitControl(Control control, Context context) {
<span class="nc bnc" id="L245" title="All 2 branches missed.">    assert context != null;</span>

    // visit params
<span class="nc" id="L248">    boolean retval = handle(</span>
        TargetType.PARAM,
<span class="nc" id="L250">        () -&gt; CollectionUtil.listOrEmpty(control.getParams()),</span>
<span class="nc" id="L251">        child -&gt; visitParameter(ObjectUtils.notNull(child), context),</span>
        context);

    // visit props
<span class="nc bnc" id="L255" title="All 4 branches missed.">    retval = retval || handle(</span>
        TargetType.PROP,
<span class="nc" id="L257">        () -&gt; CollectionUtil.listOrEmpty(control.getProps()),</span>
        null,
        context);

    // visit links
<span class="nc bnc" id="L262" title="All 4 branches missed.">    retval = retval || handle(</span>
        TargetType.LINK,
<span class="nc" id="L264">        () -&gt; CollectionUtil.listOrEmpty(control.getLinks()),</span>
        null,
        context);

    // visit parts
<span class="nc bnc" id="L269" title="All 4 branches missed.">    retval = retval || handle(</span>
        TargetType.PART,
<span class="nc" id="L271">        () -&gt; CollectionUtil.listOrEmpty(control.getParts()),</span>
<span class="nc" id="L272">        child -&gt; visitPart(child, context),</span>
        context);

<span class="nc" id="L275">    return retval;</span>
  }

  @Override
  public Boolean visitParameter(Parameter parameter, Context context) {
<span class="nc bnc" id="L280" title="All 2 branches missed.">    assert context != null;</span>

    // visit props
<span class="nc" id="L283">    boolean retval = handle(</span>
        TargetType.PROP,
<span class="nc" id="L285">        () -&gt; CollectionUtil.listOrEmpty(parameter.getProps()),</span>
        null,
        context);

    // visit links
<span class="nc bnc" id="L290" title="All 4 branches missed.">    retval = retval || handle(</span>
        TargetType.LINK,
<span class="nc" id="L292">        () -&gt; CollectionUtil.listOrEmpty(parameter.getLinks()),</span>
        null,
        context);
<span class="nc" id="L295">    return retval;</span>
  }

  /**
   * Visit the control part.
   *
   * @param part
   *          the bound part object
   * @param context
   *          the visitor context
   * @return {@code true} if the removal was applied or {@code false} otherwise
   */
  public boolean visitPart(ControlPart part, Context context) {
<span class="nc bnc" id="L308" title="All 2 branches missed.">    assert context != null;</span>

    // visit props
<span class="nc" id="L311">    boolean retval = handle(</span>
        TargetType.PROP,
<span class="nc" id="L313">        () -&gt; CollectionUtil.listOrEmpty(part.getProps()),</span>
        null,
        context);

    // visit links
<span class="nc bnc" id="L318" title="All 4 branches missed.">    retval = retval || handle(</span>
        TargetType.LINK,
<span class="nc" id="L320">        () -&gt; CollectionUtil.listOrEmpty(part.getLinks()),</span>
        null,
        context);

    // visit parts
<span class="nc bnc" id="L325" title="All 4 branches missed.">    retval = retval || handle(</span>
        TargetType.PART,
<span class="nc" id="L327">        () -&gt; CollectionUtil.listOrEmpty(part.getParts()),</span>
<span class="nc" id="L328">        child -&gt; visitPart(child, context),</span>
        context);
<span class="nc" id="L330">    return retval;</span>
  }

  static final class Context {
    /**
     * Types with an &quot;name&quot; flag.
     */
    @NonNull
<span class="nc" id="L338">    private static final Set&lt;TargetType&gt; NAME_TYPES = ObjectUtils.notNull(</span>
<span class="nc" id="L339">        Set.of(TargetType.PART, TargetType.PROP));</span>
    /**
     * Types with an &quot;class&quot; flag.
     */
    @NonNull
<span class="nc" id="L344">    private static final Set&lt;TargetType&gt; CLASS_TYPES = ObjectUtils.notNull(</span>
<span class="nc" id="L345">        Set.of(TargetType.PARAM, TargetType.PART, TargetType.PROP));</span>
    /**
     * Types with an &quot;id&quot; flag.
     */
    @NonNull
<span class="nc" id="L350">    private static final Set&lt;TargetType&gt; ID_TYPES = ObjectUtils.notNull(</span>
<span class="nc" id="L351">        Set.of(TargetType.PARAM, TargetType.PART));</span>
    /**
     * Types with an &quot;ns&quot; flag.
     */
    @NonNull
<span class="nc" id="L356">    private static final Set&lt;TargetType&gt; NAMESPACE_TYPES = ObjectUtils.notNull(</span>
<span class="nc" id="L357">        Set.of(TargetType.PART, TargetType.PROP));</span>

    @Nullable
    private final String objectName;
    @Nullable
    private final String objectClass;
    @Nullable
    private final String objectId;
    @Nullable
    private final String objectNamespace;
    @NonNull
    private final Set&lt;TargetType&gt; targetItemTypes;

    private static boolean filterTypes(
        @NonNull Set&lt;TargetType&gt; effectiveTypes,
        @NonNull String criteria,
        @NonNull Set&lt;TargetType&gt; allowedTypes,
        @Nullable String value,
        @Nullable TargetType itemType) {
<span class="nc" id="L376">      boolean retval = false;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">      if (value != null) {</span>
<span class="nc" id="L378">        retval = effectiveTypes.retainAll(allowedTypes);</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">        if (itemType != null &amp;&amp; !allowedTypes.contains(itemType)) {</span>
<span class="nc" id="L380">          throw new ProfileResolutionEvaluationException(</span>
<span class="nc" id="L381">              String.format(&quot;%s='%s' is not supported for items of type '%s'&quot;,</span>
                  criteria,
                  value,
<span class="nc" id="L384">                  itemType.fieldName()));</span>
        }
      }
<span class="nc" id="L387">      return retval;</span>
    }

    private Context(
        @Nullable String objectName,
        @Nullable String objectClass,
        @Nullable String objectId,
        @Nullable String objectNamespace,
<span class="nc" id="L395">        @Nullable TargetType itemType) {</span>

      // determine the set of effective item types to search for
      // this helps with short-circuit searching for parts of the graph that cannot
      // match
<span class="nc" id="L400">      @NonNull Set&lt;TargetType&gt; targetItemTypes = ObjectUtils.notNull(EnumSet.allOf(TargetType.class));</span>
<span class="nc" id="L401">      filterTypes(targetItemTypes, &quot;by-name&quot;, NAME_TYPES, objectName, itemType);</span>
<span class="nc" id="L402">      filterTypes(targetItemTypes, &quot;by-class&quot;, CLASS_TYPES, objectClass, itemType);</span>
<span class="nc" id="L403">      filterTypes(targetItemTypes, &quot;by-id&quot;, ID_TYPES, objectId, itemType);</span>
<span class="nc" id="L404">      filterTypes(targetItemTypes, &quot;by-ns&quot;, NAMESPACE_TYPES, objectNamespace, itemType);</span>

<span class="nc bnc" id="L406" title="All 2 branches missed.">      if (itemType != null) {</span>
<span class="nc" id="L407">        targetItemTypes.retainAll(Set.of(itemType));</span>
      }

<span class="nc bnc" id="L410" title="All 2 branches missed.">      if (targetItemTypes.isEmpty()) {</span>
<span class="nc" id="L411">        throw new ProfileResolutionEvaluationException(&quot;The filter matches no available item types&quot;);</span>
      }

<span class="nc" id="L414">      this.objectName = objectName;</span>
<span class="nc" id="L415">      this.objectClass = objectClass;</span>
<span class="nc" id="L416">      this.objectId = objectId;</span>
<span class="nc" id="L417">      this.objectNamespace = objectNamespace;</span>
<span class="nc" id="L418">      this.targetItemTypes = CollectionUtil.unmodifiableSet(targetItemTypes);</span>
<span class="nc" id="L419">    }</span>

    @Nullable
    public String getObjectName() {
<span class="nc" id="L423">      return objectName;</span>
    }

    @Nullable
    public String getObjectClass() {
<span class="nc" id="L428">      return objectClass;</span>
    }

    @Nullable
    public String getObjectId() {
<span class="nc" id="L433">      return objectId;</span>
    }

    @NonNull
    public Set&lt;TargetType&gt; getTargetItemTypes() {
<span class="nc" id="L438">      return targetItemTypes;</span>
    }

    public boolean isMatchingType(@NonNull TargetType type) {
<span class="nc" id="L442">      return getTargetItemTypes().contains(type);</span>
    }

    @Nullable
    public String getObjectNamespace() {
<span class="nc" id="L447">      return objectNamespace;</span>
    }

    private static boolean checkValue(@Nullable String actual, @Nullable String expected) {
<span class="nc bnc" id="L451" title="All 4 branches missed.">      return expected == null || expected.equals(actual);</span>
    }

    public boolean isApplicableTo(@NonNull Object obj) {
<span class="nc" id="L455">      TargetType objectType = TargetType.forClass(obj.getClass());</span>

<span class="nc bnc" id="L457" title="All 4 branches missed.">      boolean retval = objectType != null &amp;&amp; getTargetItemTypes().contains(objectType);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">      if (retval) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">        assert objectType != null;</span>

        // check other criteria
<span class="nc" id="L462">        String actualName = null;</span>
<span class="nc" id="L463">        String actualClass = null;</span>
<span class="nc" id="L464">        String actualId = null;</span>
<span class="nc" id="L465">        String actualNamespace = null;</span>

<span class="nc bnc" id="L467" title="All 5 branches missed.">        switch (objectType) {</span>
        case PARAM: {
<span class="nc" id="L469">          Parameter param = (Parameter) obj;</span>
<span class="nc" id="L470">          actualClass = param.getClazz();</span>
<span class="nc" id="L471">          actualId = param.getId();</span>
<span class="nc" id="L472">          break;</span>
        }
        case PROP: {
<span class="nc" id="L475">          Property prop = (Property) obj;</span>
<span class="nc" id="L476">          actualName = prop.getName();</span>
<span class="nc" id="L477">          actualClass = prop.getClazz();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">          actualNamespace = prop.getNs() == null ? IProperty.OSCAL_NAMESPACE.toString() : prop.getNs().toString();</span>
<span class="nc" id="L479">          break;</span>
        }
        case PART: {
<span class="nc" id="L482">          ControlPart part = (ControlPart) obj;</span>
<span class="nc" id="L483">          actualName = part.getName();</span>
<span class="nc" id="L484">          actualClass = part.getClazz();</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">          actualId = part.getId() == null ? null : part.getId().toString();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">          actualNamespace = part.getNs() == null ? IProperty.OSCAL_NAMESPACE.toString() : part.getNs().toString();</span>
<span class="nc" id="L487">          break;</span>
        }
        case LINK:
          // do nothing
<span class="nc" id="L491">          break;</span>
        default:
<span class="nc" id="L493">          throw new UnsupportedOperationException(objectType.name().toLowerCase(Locale.ROOT));</span>
        }

<span class="nc bnc" id="L496" title="All 2 branches missed.">        retval = checkValue(actualName, getObjectName())</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            &amp;&amp; checkValue(actualClass, getObjectClass())</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">            &amp;&amp; checkValue(actualId, getObjectId())</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            &amp;&amp; checkValue(actualNamespace, getObjectNamespace());</span>
      }
<span class="nc" id="L501">      return retval;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>